Old fly checks incase I need them lol:




			// Fly/B = Checks for vertical Fly
			// Fly/G damn near renders this check usesless but I'm not removing it incase mojong become more useless and removes shit that it depends on, it also false flags
			if(config.modules.flyB.enabled && !player.isFlying && !player.hasTag("op") && !player.hasTag("nofly") && !player.hasTag("damaged") && !player.getEffect("jump_boost") && !player.hasTag("slime")) {

				const hVelocity = Math.abs((playerVelocity.x + playerVelocity.z) / 2);
				const yVelocity = playerVelocity.y;
				if(aroundAir(player) === true && playerVelocity.y > config.modules.flyB.minVelocity && hVelocity < config.modules.flyB.MaxHVelocity && !player.hasTag("op") && !player.isJumping && !player.hasTag("gliding") && !player.hasTag("attacked") && !player.hasTag("riding") && !player.hasTag("levitating") && player.hasTag("moving") && !player.getEffect("speed") && yVelocity > 1.0) {
					flag(player, "Fly", "B", "Movement", "yVelocity", Math.abs(playerVelocity.y), false);
				} 
			}

			// Fly C = Checks for having invalid velocity while in the air
			if (config.modules.flyC.enabled && !player.hasTag("op") && !player.isFlying && !player.hasTag("ground") && !player.isJumping && !player.hasTag("nofly") && !player.hasTag("damaged")) {
				const vertical_velo = playerVelocity.y;
				if(playerSpeed > 0.1 && vertical_velo === 0 && !player.hasTag("ground") && playerSpeed > config.modules.speedA.speed - 0.1 && aroundAir(player) && !player.getEffect("speed")) {
					flag(player, "Fly", "C", "Movement", "vertical", vertical_velo, true)
					currentVL++;
				}
			}

			//Fly/D = Checks for fly like velocity
			// This check is really scuffed because when I made it (in my old anticheat) I had no idea what I was talking about, but it works for some reason...
			if(config.modules.flyD.enabled && !player.hasTag("op") && !player.isFlying && !player.hasTag("nofly") && !player.hasTag("damaged") && !player.hasTag("slime")) {
				const makeYVelocity1 = Math.abs(playerVelocity.x + playerVelocity.z)
				const yVelocity = Math.abs(makeYVelocity1 / 2)
				if(playerVelocity.y > yVelocity && playerVelocity.x > config.modules.flyD.Velocity && aroundAir(player) && !player.getEffect("speed")) {
					if(!player.isJumping || player.hasTag("sneak") || player.isSneaking) {
						flag(player, "Fly", "D", "Movement", "velocity", Math.abs(playerVelocity.y).toFixed(4), true);
					}
				}
			}

			// Fly/E = Checks for being in air but not falling
			if(config.modules.flyE.enabled && !player.isFlying && !player.hasTag("op") && !player.hasTag("nofly") && !player.hasTag("damaged") && !player.hasTag("ground")) {
				if(playerVelocity.y === 0) {
					const findHVelocity = Math.abs((playerVelocity.x + playerVelocity.z) / 2);
					
					if(aroundAir(player) === true && findHVelocity > config.modules.flyE.hVelocity && !player.getEffect("speed")) {
						if(!player.isJumping || player.hasTag("sneak") || player.isSneaking) {
							flag(player, "Fly", "E", "Movement", "yVelocity", Math.abs(player.velocityV).toFixed(4), true);
							player.addTag("strict");
						}
					}          
				}
			}




                    "flyA": {
            "enabled": true,
            "punishment": "kick",
            "punishmentLength": "5m",
            "minVlbeforePunishment": 10
        },    
        "flyB": {
            "enabled": true,
            "description":"Checks for invalid vertical velocity",
            "minVelocity": 0.53234201,
            "punishment": "none",
            "MaxHVelocity": 0.5234,
            "minVlbeforePunishment": 0
        },
        "flyC": {
            "enabled": true,
            "velocity": 0.5423,
            "description":"Checks for invalid speed and velocity in air",
            "hVelocity": 0.525,
            "punishment": "kick",
            "punishmentLength": "5m",
            "minVlbeforePunishment": 3
        },          
        "flyD": {
            "enabled": true,
            "Velocity": 0.6,
            "description":"Checks for invalid horizontal velocity in air",
            "punishment": "kick",
            "punishmentLength": "5m",
            "minVlbeforePunishment": 5
        },    
        "flyE": {
            "enabled": true,
            "description":"Checks for invalid horizontal velocity in air",
            "hVelocity": 0.512,
            "punishment": "kick",
            "punishmentLength": "5d",
            "minVlbeforePunishment": 10
        },        

        // Do **NOT** enabled
        // The check is broken
        "flyF": {
            "enabled": true,
            "description": "In air velocity check",
            "punishment": "kick", 
            "diff": 0.1,
            "speed": 2.45,
            "punishmentLength": "3d",
            "minVlbeforePunishment": 10
        },   
        "flyG": {
            "enabled": true,
            "description": "Checks for invalid Y movements (Scythe Check So Bad)",
            "fallDistance": 0,
            "punishment": "kick",
            "punishmentLength": "1m",
            "minVlbeforePunishment": 100
        },


Old speed check 
			// Speed/B = 1.2e-10
			// if(config.modules.speedB.enabled && player.hasTag("strict")) {
			// 	// Get the player's current speed and rotation
			// 	const currentSpeed = playerSpeed
			// 	const currentRotation = rotation.y;
			// 	// Get the player's previous speed and rotation
			// 	const oldSpeed = previousSpeedLog.get(player) || currentSpeed;
			// 	const oldRotation = previousRotationLog.get(player) || currentRotation;
			// 	const oldSpeed2 = oldOldSpeed.get(player) || oldSpeed;
			// 	// If the player's rotation has changed but their speed has not decreased, flag for Speed
			// 	if(Math.abs(currentRotation - oldRotation) > 40 + 1.2e-10 && currentSpeed >= oldSpeed + 0.1 && playerSpeed !== 0 && player.hasTag("moving") && Math.abs(currentRotation - oldRotation) !== 0 && playerSpeed > 0.48 && !player.hasTag("damaged") && player.hasTag("strict") && !player.getEffect("speed") && !player.hasTag("nospeed") && !player.hasTag("ice") && !player.hasTag("slime")) {
			// 		flag(player, "Speed", "B", "Movement", "rotationDiff", `${Math.abs(currentRotation - oldRotation)},speed=${currentSpeed}`)
			// 	}

			// 	// Update the player's previous speed and rotation
			// 	oldOldSpeed.set(player, oldSpeed);
			// 	previousSpeedLog.set(player, currentSpeed);
			// 	previousRotationLog.set(player, currentRotation);
			// }





			// // Check for small head snaps
			// const rotationThreshold = 5;
			// const maxRotation = 10;
			// if (
			// 	lastAttackVector2Angle.get(player) &&
			// 	lastAttackVector2Angle.get(player).x !== undefined &&
			// 	lastAttackVector2Angle.get(player).y !== undefined &&
			// 	(
			// 		(Math.abs(lastAttackVector2Angle.get(player).x - attackVector2Angle.x) > 0 &&
			// 		Number.isInteger(Math.abs(lastAttackVector2Angle.get(player).x - attackVector2Angle.x))) ||
			// 		(Math.abs(lastAttackVector2Angle.get(player).y - attackVector2Angle.y) > 0 &&
			// 		Number.isInteger(Math.abs(lastAttackVector2Angle.get(player).y - attackVector2Angle.y)))
			// 	)
			// 	) {
			// 	if (getScore(player, "auraF_buffer", 0) > 10) {
			// 		flag(player, "Killaura", "F", "Combat", "angleDiff(2)", `${Math.abs(lastAttackVector2Angle.get(player).x - attackVector2Angle.x)}, ${Math.abs(lastAttackVector2Angle.get(player).y - attackVector2Angle.y)}`, true);
			// 		setScore(player, "auraF_buffer", 0);
			// 	} else {
			// 		setScore(player, "auraF_buffer", getScore(player, "auraF_buffer", 0) + 1);
			// 	}
			// }
			// if (lastAttackVector2Angle.get(player)) {
			// 	console.warn(`|| LOGS || (KILLAURA) [F] - Angle Diff 1 ${Math.abs(lastAttackVector2Angle.get(player).x - attackVector2Angle.x)}, Angle Diff 2 ${Math.abs(lastAttackVector2Angle.get(player).y - attackVector2Angle.y)}`);
			// }


			// // Large changes in yaw without large changes in pitch could be a sign of someone using Killaura cheats
			// if(lastAttackVector2Angle.get(player) && lastAttackVector2Angle.get(player).x !== undefined && lastAttackVector2Angle.get(player).y !== undefined) {
			// 	if(Math.abs(lastAttackVector2Angle.get(player).x - attackVector2Angle.x) < 10 && Math.abs(lastAttackVector2Angle.get(player).y - attackVector2Angle.y) > 30 && Math.abs(lastAttackVector2Angle.get(player).x - attackVector2Angle.x) > 5) {
			// 		if (getScore(player, "auraF_buffer", 0) > 10) {
			// 			flag(player, "Killaura", "F", "Combat", "angleDiff(3)", `${Math.abs(lastAttackVector2Angle.get(player).x - attackVector2Angle.x)}, ${Math.abs(lastAttackVector2Angle.get(player).y - attackVector2Angle.y)}`, true);
			// 			setScore(player, "auraF_buffer", 0);
			// 		} else {
			// 			setScore(player, "auraF_buffer", getScore(player, "auraF_buffer", 0) + 1);
			// 		}
			// 	}
			// }






			    // try {
    //     if(config.modules.scaffoldA.enabled && scaffold_a_map.get(player)) {
    //         const place_location = {x: block.location.x, y: block.location.y, z: block.location.z};
    //         const last_place_location = scaffold_a_map.get(player).a;
    //         const old_place_location = scaffold_a_map.get(player).b;
    //         const pitch_values = scaffold_a_map.get(player).pitch;
    //         if(Math.abs(old_place_location.x) === Math.abs(last_place_location.x) && Math.abs(last_place_location.x) !== Math.abs(place_location.x)) {
    //             if(Math.abs(pitch_values.old - pitch_values.mid) < 3 && Math.abs(pitch_values.mid - player.getRotation().x) > 30) {
    //                 flag(player, "Scaffold", "A", "World", "pitch", player.getRotation().x, false);
    //             }
    //         }
            
    //         if(Math.abs(old_place_location.z === last_place_location.z)) {
    //             console.log("e");
    //         }
    //     }
    // } catch (e) {
    //     console.log(e);
    // }
    // try {
    //     scaffold_a_map.set(
    //         player,
    //         {a: {x: block.location.x, y: block.location.y, z: block.location.z},
    //         b: scaffold_a_map.get(player).a || 0,
    //         pitch: {new: player.getRotation().x, mid: scaffold_a_map.get(player).pitch.new || 0, old: scaffold_a_map.get(player).pitch.mid || 0},
    //         yaw: {new: player.getRotation().z, mid: scaffold_a_map.get(player).yaw.new || 0, old: scaffold_a_map.get(player).yaw.mid || 0}
    //     }
    //     );
    // } catch (e) {console.log(e)}

	# __Isolate Anticheat__
## v7.0.2

> Isolate Anticheat v7.0.2 has fixed many bypasses and false flags

This release still has false flags, tho by default, they won't autokick
I needed to get this release out because it fixed some false flags and bypasses (I also kept saying I would release then not doing it)

**__Things that were added__**

[+] Motion/D (e)